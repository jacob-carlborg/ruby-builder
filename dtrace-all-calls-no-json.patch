diff --git a/doc/contributing/dtrace_probes.rdoc b/doc/contributing/dtrace_probes.rdoc
index 1b20597ab4..5c6978db3e 100644
--- a/doc/contributing/dtrace_probes.rdoc
+++ b/doc/contributing/dtrace_probes.rdoc
@@ -57,16 +57,10 @@ with when they are fired and the arguments they take:
   filename::     the file name where the method is _being called_ (a string)
   lineno::       the line number where the method is _being called_ (an int)
 
-  *NOTE*: will only be fired if tracing is enabled, e.g. with: <code>TracePoint.new{}.enable</code>.
-  See Feature#14104[https://bugs.ruby-lang.org/issues/14104] for more details.
-
 [ruby:::method-return(classname, methodname, filename, lineno);]
   This probe is fired just after a method has returned. The arguments are the
   same as "ruby:::method-entry".
 
-  *NOTE*: will only be fired if tracing is enabled, e.g. with: <code>TracePoint.new{}.enable</code>.
-  See Feature#14104[https://bugs.ruby-lang.org/issues/14104] for more details.
-
 [ruby:::cmethod-entry(classname, methodname, filename, lineno);]
   This probe is fired just before a C method is entered. The arguments are the
   same as "ruby:::method-entry".
diff --git a/insns.def b/insns.def
index 7df3672615..ff9790f70e 100644
--- a/insns.def
+++ b/insns.def
@@ -1170,6 +1170,10 @@ leave
         }
     }
 
+    if (VM_FRAME_TYPE(GET_CFP()) == VM_FRAME_MAGIC_METHOD) {
+        RUBY_DTRACE_METHOD_RETURN_HOOK(ec, 0, 0);
+    }
+
     if (vm_pop_frame(ec, GET_CFP(), GET_EP())) {
 #if OPT_CALL_THREADED_CODE
         rb_ec_thread_ptr(ec)->retval = val;
@@ -1677,6 +1681,10 @@ opt_invokebuiltin_delegate_leave
 
     /* leave fastpath */
     /* TracePoint/return fallbacks this insn to opt_invokebuiltin_delegate */
+    if (VM_FRAME_TYPE(GET_CFP()) == VM_FRAME_MAGIC_METHOD) {
+        RUBY_DTRACE_METHOD_RETURN_HOOK(ec, 0, 0);
+    }
+
     if (vm_pop_frame(ec, GET_CFP(), GET_EP())) {
 #if OPT_CALL_THREADED_CODE
         rb_ec_thread_ptr(ec)->retval = val;
diff --git a/test/dtrace/test_function_entry.rb b/test/dtrace/test_function_entry.rb
index e2395ab15a..e7763f63d2 100644
--- a/test/dtrace/test_function_entry.rb
+++ b/test/dtrace/test_function_entry.rb
@@ -18,12 +18,84 @@ def test_function_entry
 	}
 
 	assert_equal 10, foo_calls.length, probes
-	line = '3'
+	line = '6'
+	foo_calls.each { |f| assert_equal line, f[3] }
+	foo_calls.each { |f| assert_equal rb_file, f[2] }
+      }
+    end
+
+    def test_function_entry_without_trace_point
+      probe = <<-eoprobe
+ruby$target:::method-entry
+/arg0 && arg1 && arg2/
+{
+  printf("%s %s %s %d\\n", copyinstr(arg0), copyinstr(arg1), copyinstr(arg2), arg3);
+}
+      eoprobe
+
+      trap_probe(probe, ruby_program_without_trace_point) { |d_file, rb_file, probes|
+	foo_calls = probes.map { |line| line.split }.find_all { |row|
+	  row.first == 'Foo'  && row[1] == 'foo'
+	}
+
+	assert_equal 10, foo_calls.length, probes
+	line = '5'
 	foo_calls.each { |f| assert_equal line, f[3] }
 	foo_calls.each { |f| assert_equal rb_file, f[2] }
       }
     end
 
+    def test_tailcall_function_entry_without_trace_point
+      program = <<-eoruby
+      code = <<~RUBY
+        class Foo
+          def foo
+            bar
+          end
+
+          def bar
+            3 + 4
+          end
+        end
+
+        Foo.new.foo
+      RUBY
+
+      RubyVM::InstructionSequence.compile(
+        code,
+        tailcall_optimization: true,
+        trace_instruction: false
+      ).eval
+      eoruby
+
+      probe = <<-eoprobe
+ruby$target:::method-entry
+/arg0 && arg1 && arg2/
+{
+  printf("%s %s %s %d\\n", copyinstr(arg0), copyinstr(arg1), copyinstr(arg2), arg3);
+}
+      eoprobe
+
+      trap_probe(probe, program) { |d_file, rb_file, probes|
+	foo_calls = probes.map { |line| line.split }.find_all { |row|
+	  row.first == 'Foo'  && row[1] == 'foo'
+	}
+
+	bar_calls = probes.map { |line| line.split }.find_all { |row|
+	  row.first == 'Foo'  && row[1] == 'bar'
+	}
+
+  assert_equal 1, foo_calls.length, probes
+  assert_equal 1, bar_calls.length, probes
+
+  assert_equal '11', foo_calls.first[3]
+  assert_equal '<compiled>', foo_calls.first[2]
+
+  assert_equal '11', bar_calls.first[3]
+  assert_equal '<compiled>', bar_calls.first[2]
+      }
+    end
+
     def test_function_return
       probe = <<-eoprobe
 ruby$target:::method-return
@@ -45,6 +117,27 @@ def test_function_return
       }
     end
 
+    def test_function_return_without_trace_point
+      probe = <<-eoprobe
+ruby$target:::method-return
+/arg0 && arg1 && arg2/
+{
+  printf("%s %s %s %d\\n", copyinstr(arg0), copyinstr(arg1), copyinstr(arg2), arg3);
+}
+      eoprobe
+
+      trap_probe(probe, ruby_program_without_trace_point) { |d_file, rb_file, probes|
+	foo_calls = probes.map { |line| line.split }.find_all { |row|
+	  row.first == 'Foo'  && row[1] == 'foo'
+	}
+
+	assert_equal 10, foo_calls.length, probes.inspect
+	line = '2'
+	foo_calls.each { |f| assert_equal line, f[3] }
+	foo_calls.each { |f| assert_equal rb_file, f[2] }
+      }
+    end
+
     def test_return_from_raise
       program = <<-eoruby
       class Foo
@@ -77,7 +170,17 @@ def baz
     private
     def ruby_program
       <<-eoruby
-      TracePoint.new{}.__enable(nil, nil, Thread.current)
+      TracePoint.new{}.enable.__enable(nil, nil, Thread.current)
+      class Foo
+	def foo; end
+      end
+      x = Foo.new
+      10.times { x.foo }
+      eoruby
+    end
+
+    def ruby_program_without_trace_point
+      <<-eoruby
       class Foo
 	def foo; end
       end
diff --git a/test/dtrace/test_singleton_function.rb b/test/dtrace/test_singleton_function.rb
index bad1fa0692..e56127fe60 100644
--- a/test/dtrace/test_singleton_function.rb
+++ b/test/dtrace/test_singleton_function.rb
@@ -18,7 +18,28 @@ def test_entry
 	}
 
 	assert_equal 10, foo_calls.length, probes.inspect
-	line = '3'
+	line = '5'
+	foo_calls.each { |f| assert_equal line, f[3] }
+	foo_calls.each { |f| assert_equal rb_file, f[2] }
+      }
+    end
+
+    def test_entry_without_trace_point
+      probe = <<-eoprobe
+ruby$target:::method-entry
+/strstr(copyinstr(arg0), "Foo") != NULL/
+{
+  printf("%s %s %s %d\\n", copyinstr(arg0), copyinstr(arg1), copyinstr(arg2), arg3);
+}
+      eoprobe
+
+      trap_probe(probe, ruby_program_without_trace_point) { |d_file, rb_file, probes|
+	foo_calls = probes.map { |line| line.split }.find_all { |row|
+	  row.first == 'Foo'  && row[1] == 'foo'
+	}
+
+	assert_equal 10, foo_calls.length, probes.inspect
+	line = '4'
 	foo_calls.each { |f| assert_equal line, f[3] }
 	foo_calls.each { |f| assert_equal rb_file, f[2] }
       }
@@ -44,6 +65,26 @@ def test_exit
       }
     end
 
+    def test_exit_without_trace_point
+      probe = <<-eoprobe
+ruby$target:::method-return
+{
+  printf("%s %s %s %d\\n", copyinstr(arg0), copyinstr(arg1), copyinstr(arg2), arg3);
+}
+      eoprobe
+
+      trap_probe(probe, ruby_program_without_trace_point) { |d_file, rb_file, probes|
+	foo_calls = probes.map { |line| line.split }.find_all { |row|
+	  row.first == 'Foo'  && row[1] == 'foo'
+	}
+
+	assert_equal 10, foo_calls.length, probes.inspect
+	line = '2'
+	foo_calls.each { |f| assert_equal line, f[3] }
+	foo_calls.each { |f| assert_equal rb_file, f[2] }
+      }
+    end
+
     def ruby_program
       <<-eoruby
       TracePoint.new{}.__enable(nil, nil, Thread.current)
@@ -53,5 +94,14 @@ def self.foo; end
       10.times { Foo.foo }
       eoruby
     end
+
+    def ruby_program_without_trace_point
+      <<-eoruby
+      class Foo
+	def self.foo; end
+      end
+      10.times { Foo.foo }
+      eoruby
+    end
   end
 end if defined?(DTrace::TestCase)
diff --git a/vm_insnhelper.c b/vm_insnhelper.c
index 60e1b647ae..54d0c8302d 100644
--- a/vm_insnhelper.c
+++ b/vm_insnhelper.c
@@ -3485,6 +3485,9 @@ vm_call_iseq_setup_normal(rb_execution_context_t *ec, rb_control_frame_t *cfp, s
                           int opt_pc, int param_size, int local_size)
 {
     const rb_iseq_t *iseq = def_iseq_ptr(me->def);
+
+    RUBY_DTRACE_METHOD_ENTRY_HOOK(ec, me->owner, me->def->original_id);
+
     VALUE *argv = cfp->sp - calling->argc;
     VALUE *sp = argv + param_size;
     cfp->sp = argv - 1 /* recv */;
@@ -3521,6 +3524,10 @@ vm_call_iseq_setup_tailcall(rb_execution_context_t *ec, rb_control_frame_t *cfp,
         }
     }
 
+    if (VM_FRAME_TYPE(cfp) == VM_FRAME_MAGIC_METHOD) {
+        RUBY_DTRACE_METHOD_RETURN_HOOK(ec, 0, 0);
+    }
+
     vm_pop_frame(ec, cfp, cfp->ep);
     cfp = ec->cfp;
 
@@ -3535,6 +3542,8 @@ vm_call_iseq_setup_tailcall(rb_execution_context_t *ec, rb_control_frame_t *cfp,
         *sp++ = src_argv[i];
     }
 
+    RUBY_DTRACE_METHOD_ENTRY_HOOK(ec, me->owner, me->def->original_id);
+
     vm_push_frame(ec, iseq, VM_FRAME_MAGIC_METHOD | VM_ENV_FLAG_LOCAL | finish_flag,
                   calling->recv, calling->block_handler, (VALUE)me,
                   ISEQ_BODY(iseq)->iseq_encoded + opt_pc, sp,
@@ -5806,30 +5815,6 @@ vm_check_keyword(lindex_t bits, lindex_t idx, const VALUE *ep)
     return Qtrue;
 }
 
-static void
-vm_dtrace(rb_event_flag_t flag, rb_execution_context_t *ec)
-{
-    if (RUBY_DTRACE_METHOD_ENTRY_ENABLED() ||
-        RUBY_DTRACE_METHOD_RETURN_ENABLED() ||
-        RUBY_DTRACE_CMETHOD_ENTRY_ENABLED() ||
-        RUBY_DTRACE_CMETHOD_RETURN_ENABLED()) {
-
-        switch (flag) {
-          case RUBY_EVENT_CALL:
-            RUBY_DTRACE_METHOD_ENTRY_HOOK(ec, 0, 0);
-            return;
-          case RUBY_EVENT_C_CALL:
-            RUBY_DTRACE_CMETHOD_ENTRY_HOOK(ec, 0, 0);
-            return;
-          case RUBY_EVENT_RETURN:
-            RUBY_DTRACE_METHOD_RETURN_HOOK(ec, 0, 0);
-            return;
-          case RUBY_EVENT_C_RETURN:
-            RUBY_DTRACE_CMETHOD_RETURN_HOOK(ec, 0, 0);
-            return;
-        }
-    }
-}
 
 static VALUE
 vm_const_get_under(ID id, rb_num_t flags, VALUE cbase)
@@ -7203,7 +7188,6 @@ vm_trace_hook(rb_execution_context_t *ec, rb_control_frame_t *reg_cfp, const VAL
     if (event & global_hooks->events) {
         /* increment PC because source line is calculated with PC-1 */
         reg_cfp->pc++;
-        vm_dtrace(event, ec);
         rb_exec_event_hook_orig(ec, global_hooks, event, self, 0, 0, 0 , val, 0);
         reg_cfp->pc--;
     }
